// Generated by CoffeeScript 1.9.3
(function() {
  var Lua, constants, constantsLua, fs, intercept, jsonLua, k, pathlib, state;

  fs = require('fs');

  intercept = require('intercept-stdout');

  pathlib = require('path');

  Lua = require('lua.vm.js').Lua;

  state = new Lua.State();

  jsonLua = fs.readFileSync(pathlib.join(__dirname, 'JSON.lua'), 'utf8');

  jsonLua = jsonLua.replace(/local OBJDEF = {[^}]+}/, function(match) {
    return match + '\nJSON = OBJDEF\n';
  });

  constants = ['STREAM_INPUT', 'STREAM_OUTPUT', 'TILE_COMPUTE', 'TILE_MEMORY', 'TILE_DAMAGED'];

  constantsLua = ((function() {
    var j, len, results;
    results = [];
    for (j = 0, len = constants.length; j < len; j++) {
      k = constants[j];
      results.push(k + " = \"" + k + "\"\n");
    }
    return results;
  })()).join('');

  exports.parse = function(contents) {
    var call, captureOutput, catchLuaError, e, i, index, j, l, layout, layoutWidth, len, len1, name, ref, stream, streams, type;
    catchLuaError = function(fn) {
      var err;
      try {
        return fn();
      } catch (_error) {
        err = _error;
        throw new Error("Error in Lua spec: " + err.message + "\n" + err.lua_stack);
      }
    };
    captureOutput = function(code) {
      var buf, e, unhook;
      buf = "";
      try {
        unhook = intercept(function(chunk) {
          buf += chunk;
          return '';
        });
        catchLuaError(function() {
          return state.execute(code);
        });
      } finally {
        unhook();
      }
      try {
        return JSON.parse(buf);
      } catch (_error) {
        e = _error;
        throw new Error("Couldn't parse results of code '" + code + "': " + buf);
      }
    };
    catchLuaError(function() {
      state.execute(constantsLua);
      state.execute(contents);
      return state.execute(jsonLua);
    });
    call = function(name) {
      return captureOutput("print(JSON:encode(" + name + "()))");
    };
    try {
      layoutWidth = call('get_layout_width');
    } catch (_error) {
      e = _error;
      layoutWidth = 4;
    }
    layout = call('get_layout');
    streams = call('get_streams');
    if (layoutWidth <= 0) {
      throw new Error("Layout width must be > 0 (was " + layoutWidth + ")");
    }
    if (layout.length < layoutWidth) {
      throw new Error("Layout must specify at least " + layoutWidth + " nodes (got " + layout.length + ")");
    }
    if (layout.length % layoutWidth) {
      throw new Error("Layout must specify multiple of " + layoutWidth + " nodes");
    }
    for (i = j = 0, len = layout.length; j < len; i = ++j) {
      type = layout[i];
      if (type !== 'TILE_COMPUTE' && type !== 'TILE_DAMAGED' && type !== 'TILE_MEMORY') {
        throw new Error("Unknown tile type '" + type + "' at node " + i);
      }
    }
    for (i = l = 0, len1 = streams.length; l < len1; i = ++l) {
      ref = streams[i], type = ref[0], name = ref[1], index = ref[2], stream = ref[3];
      if (type !== 'STREAM_INPUT' && type !== 'STREAM_OUTPUT') {
        throw new Error("Unknown stream type '" + type + "' at stream " + i);
      }
      if (!/\S/.test(name)) {
        throw new Error("Stream " + i + " needs a name");
      }
      if (index < 0 || index >= layoutWidth) {
        throw new Error("Stream " + i + " position must be between 0 and " + (layoutWidth - 1));
      }
    }
    return {
      name: call('get_name'),
      description: call('get_description'),
      streams: streams,
      layout: layout,
      layoutWidth: layoutWidth
    };
  };

}).call(this);
