// Generated by CoffeeScript 1.9.3
(function() {
  var CheckError, Emulator, JUMP_SOURCES, LABEL_NAMES, MAX_INT, MAX_LINES, MIN_INT, NAMED_DESTINATIONS, NAMED_SOURCES, OPERATORS, OPER_WEIGHTS, OP_ALTERATION, OP_CROSSOVER, OP_MUTATION, OP_REPRODUCTION, Random, alterAST, calculateFitness, clone, cluster, crossoverAST, debug, extractLabels, generateLine, generateRandomAST, generateSomewhatCorrectAST, generateValidAST, growNode, keypress, mt, mutateAST, newLabel, pickChild, pickFromWeights, random, randomDest, randomLabel, randomOperator, randomSource, ref, ref1, solve;

  Random = require('random-js');

  clone = require('clone');

  cluster = require('cluster');

  debug = require('debug');

  keypress = require('keypress');

  ref = require('./emulator'), MAX_INT = ref.MAX_INT, MIN_INT = ref.MIN_INT, MAX_LINES = ref.MAX_LINES, Emulator = ref.Emulator, CheckError = ref.CheckError;

  debug.enable('genetics');

  debug = debug('genetics');

  mt = Random.engines.mt19937();

  mt.autoSeed();

  random = new Random(mt);

  LABEL_NAMES = 'ABCDEFGHIJKLMNOJKLMNOPQRSTUVWXYZ'.split('');

  OPERATORS = ['NOP', 'MOV', 'SWP', 'SAV', 'ADD', 'SUB', 'NEG', 'JMP', 'JEZ', 'JNZ', 'JGZ', 'JLZ', 'JRO'];

  OPER_WEIGHTS = [1, 5, 2, 2, 4, 4, 3, 1, 1, 1, 1, 1, 1];

  NAMED_SOURCES = ['UP', 'RIGHT', 'DOWN', 'LEFT', 'NIL', 'ACC', 'ANY', 'LAST'];

  NAMED_DESTINATIONS = ['UP', 'RIGHT', 'DOWN', 'LEFT', 'NIL', 'ACC', 'ANY', 'LAST'];

  JUMP_SOURCES = ['UP', 'RIGHT', 'DOWN', 'LEFT', 'ANY', 'LAST'];

  ref1 = [0, 1, 2, 3], OP_REPRODUCTION = ref1[0], OP_CROSSOVER = ref1[1], OP_MUTATION = ref1[2], OP_ALTERATION = ref1[3];

  calculateFitness = function(emu) {
    emu.calculateStats();
    return (emu.stats.correctness * 0.45) + (emu.stats.finished ? 0.45 : 0.0) + (emu.stats.outputStddev > 0 ? 0.1 : 0.0);
  };

  pickFromWeights = function(arr) {
    var i, j, k, len, p, ref2, t, total, w;
    total = 0;
    for (j = 0, len = arr.length; j < len; j++) {
      w = arr[j];
      total += w;
    }
    if (total === 0) {
      return random.pick(arr);
    } else {
      p = random.real(0, total);
      t = 0;
      for (i = k = 0, ref2 = arr.length; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
        t += arr[i];
        if (p < t) {
          return i;
        }
      }
      return i;
    }
  };

  newLabel = function(labels) {
    var pick;
    while (true) {
      pick = random.pick(LABEL_NAMES);
      if (!(pick in labels)) {
        break;
      }
    }
    return pick;
  };

  randomLabel = function(labels) {
    return random.pick(Object.keys(labels));
  };

  randomSource = function() {
    if (random.bool()) {
      return random.pick(NAMED_SOURCES);
    } else {
      if (random.bool(0.66)) {
        return random.integer(-10, 10);
      } else {
        return random.integer(MIN_INT, MAX_INT);
      }
    }
  };

  randomDest = function() {
    return random.pick(NAMED_DESTINATIONS);
  };

  randomOperator = function() {
    return OPERATORS[pickFromWeights(OPER_WEIGHTS)];
  };

  extractLabels = function(node) {
    var j, labels, len, line, ref2;
    labels = {};
    ref2 = node.lines;
    for (j = 0, len = ref2.length; j < len; j++) {
      line = ref2[j];
      if (line.label != null) {
        labels[line.label] = true;
      }
    }
    return labels;
  };

  generateLine = function(node) {
    var label, labels, lines, offset, op;
    lines = node.lines;
    labels = extractLabels(node);
    label = newLabel(labels);
    while (true) {
      op = randomOperator();
      if (!((op === 'JMP' || op === 'JEZ' || op === 'JNZ' || op === 'JGZ' || op === 'JLZ') && Object.keys(labels).length === 0)) {
        break;
      }
    }
    switch (op) {
      case 'NOP':
      case 'SWP':
      case 'SAV':
      case 'NEG':
        return {
          label: label,
          instruction: [op]
        };
      case 'ADD':
      case 'SUB':
        return {
          label: label,
          instruction: [op, randomSource()]
        };
      case 'MOV':
        return {
          label: label,
          instruction: [op, randomSource(), randomDest()]
        };
      case 'JMP':
      case 'JEZ':
      case 'JNZ':
      case 'JGZ':
      case 'JLZ':
        return {
          label: label,
          instruction: [op, randomLabel(labels)]
        };
      case 'JRO':
        offset = random.pick([
          function() {
            return random.integer(-MAX_LINES, MAX_LINES);
          }, function() {
            return random.integer(MIN_INT, MAX_INT);
          }, function() {
            return random.pick(JUMP_SOURCES);
          }
        ])();
        return {
          label: label,
          instruction: [op, offset]
        };
    }
  };

  growNode = function(node) {
    var line;
    line = generateLine(node);
    node.lines.push(line);
    random.shuffle(node.lines);
  };

  generateRandomAST = function(layout, layoutWidth, streams) {
    var ast, i, index, j, k, l, len, name, node, nodesByLayout, numComputeNodes, numInstructions, pos, ref2, ref3, ref4, stream, tries, type;
    ast = {
      tisasm: 1,
      nodes: []
    };
    index = 0;
    nodesByLayout = new Array(layout.length);
    for (i = j = 0, ref2 = layout.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
      if (layout[i] === 'TILE_COMPUTE') {
        node = {
          index: index++,
          lines: []
        };
        ast.nodes.push(node);
        nodesByLayout[i] = node;
      }
    }
    numComputeNodes = ast.nodes.length;
    numInstructions = random.integer(1, numComputeNodes * MAX_LINES);
    for (k = 0, len = streams.length; k < len; k++) {
      ref3 = streams[k], type = ref3[0], name = ref3[1], pos = ref3[2], stream = ref3[3];
      if (type === 'STREAM_INPUT') {
        node = nodesByLayout[pos];
        node.lines.push({
          label: null,
          instruction: ['MOV', 'UP', randomDest()]
        });
      } else {
        node = nodesByLayout[layout.length + pos - layoutWidth];
        node.lines.push({
          label: null,
          instruction: ['MOV', randomSource(), 'DOWN']
        });
      }
    }
    for (i = l = 0, ref4 = numInstructions; 0 <= ref4 ? l < ref4 : l > ref4; i = 0 <= ref4 ? ++l : --l) {
      tries = 0;
      while (true) {
        node = random.pick(ast.nodes);
        if (tries++ > numInstructions) {
          break;
        }
        if (node.lines.length < MAX_LINES) {
          growNode(node);
          break;
        }
      }
    }
    return ast;
  };

  generateValidAST = function(emu, layout, layoutWidth, streams, tries) {
    var ast, e, i;
    if (tries == null) {
      tries = 1000;
    }
    i = 0;
    while (true) {
      try {
        ast = generateRandomAST(layout, layoutWidth, streams);
        emu.loadProgram(ast);
        return ast;
      } catch (_error) {
        e = _error;
        if (e instanceof CheckError) {
          debug("generated a bad AST: " + e);
        } else {
          throw e;
        }
      }
      if (i++ > tries) {
        throw new Error("Couldn't generate a working AST after " + tries + " tries");
      }
    }
  };

  generateSomewhatCorrectAST = function(emu, layout, layoutWidth, streams, tries) {
    var child, e, f, i;
    if (tries == null) {
      tries = 1000;
    }
    i = 0;
    while (true) {
      child = generateValidAST(emu, layout, layoutWidth, streams, tries);
      try {
        emu.loadProgram(child);
        emu.reset();
        emu.run(tries);
        f = calculateFitness(emu);
      } catch (_error) {
        e = _error;
        debug(e);
        f = 0;
      }
      if (f > 0) {
        return emu.ast;
      }
      if (i++ > tries) {
        throw new Error("Couldn't generate a somewhat correct AST after " + tries + " tries");
      }
    }
  };

  crossoverAST = function(a, b) {
    var child, i, j, ref2;
    child = {
      tisasm: 1,
      nodes: []
    };
    for (i = j = 0, ref2 = a.nodes.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
      if (random.bool()) {
        child.nodes.push(a.nodes[i]);
      } else {
        child.nodes.push(b.nodes[i]);
      }
    }
    return child;
  };

  mutateAST = function(parent) {
    var child, i, j, node, ref2;
    child = clone(parent);
    node = random.pick(child.nodes);
    node.lines = [];
    for (i = j = 0, ref2 = random.integer(1, MAX_LINES); 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
      growNode(node);
    }
    return child;
  };

  alterAST = function(parent) {
    var child, index, line, lines, node, op;
    child = clone(parent);
    node = random.pick(child.nodes);
    lines = node.lines;
    line = random.pick(node.lines);
    op = random.integer(0, 2);
    if (op === 0 || op === 1) {
      lines.splice(lines.indexOf(line), 1);
    }
    if (op === 1 || op === 2) {
      if (lines.length >= MAX_LINES) {
        lines.splice(lines.indexOf(line), 1);
      }
      if (lines.length > 0) {
        index = random.integer(0, lines.length);
        lines.splice(index, 0, generateLine(node));
      } else {
        growNode(node);
      }
    }
    return child;
  };

  pickChild = function(population, fitness) {
    var child, i;
    i = pickFromWeights(fitness);
    child = population[i];
    return child;
  };

  solve = function(specfile, options) {
    var a, b, child, e, emu, f, fitness, generation, i, j, k, l, layout, layoutWidth, len, len1, m, maxFitness, n, newPopulation, op, parent, pickGeneticOperation, population, ref2, ref3, ref4, ref5, streams, value;
    emu = new Emulator();
    if (specfile != null) {
      emu.load(null, specfile);
      ref2 = emu.spec, layout = ref2.layout, layoutWidth = ref2.layoutWidth, streams = ref2.streams;
    } else {
      layout = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j <= 11; i = ++j) {
          results.push('TILE_COMPUTE');
        }
        return results;
      })();
      layoutWidth = 4;
      streams = [];
    }
    generation = 0;
    population = new Array(options.children);
    fitness = new Array(options.children);
    newPopulation = new Array(options.children);
    maxFitness = 0;
    pickGeneticOperation = (function() {
      var weights;
      weights = [options.reproduction, options.crossover, options.mutation, options.alteration];
      return function() {
        return pickFromWeights(weights);
      };
    })();
    console.log("Generating initial population...");
    for (i = j = 0, ref3 = population.length; 0 <= ref3 ? j < ref3 : j > ref3; i = 0 <= ref3 ? ++j : --j) {
      child = generateSomewhatCorrectAST(emu, layout, layoutWidth, streams, options.maxRunCycles);
      console.log("Child " + (i + 1) + "/" + population.length + " fitness = " + (calculateFitness(emu)));
      population[i] = child;
    }
    while (true) {
      maxFitness = 0;
      for (i = k = 0, len = population.length; k < len; i = ++k) {
        child = population[i];
        try {
          emu.loadProgram(child);
          emu.reset();
          emu.run(options.maxRunCycles);
          f = calculateFitness(emu);
        } catch (_error) {
          e = _error;
          if (!e instanceof CheckError) {
            debug("Error with child " + i + ": " + e);
          }
          f = 0;
        }
        if (f > maxFitness) {
          maxFitness = f;
        }
        fitness[i] = f;
        if (f === 1) {
          console.log("Solved on generation " + generation + "!");
          console.log(emu.toString());
          console.log(emu.toSaveFile());
          return;
        }
      }
      if ((generation % 100) === 0) {
        console.log("Generation " + generation + " - max(fitness) = " + maxFitness);
      }
      if ((generation % 1000) === 0) {
        console.log("Showing program with the highest fitness...");
        for (i = l = 0, len1 = fitness.length; l < len1; i = ++l) {
          value = fitness[i];
          if (value === maxFitness) {
            console.log(emu.toString());
            break;
          }
        }
      }
      for (i = m = 0, ref4 = population.length; 0 <= ref4 ? m < ref4 : m > ref4; i = 0 <= ref4 ? ++m : --m) {
        op = pickGeneticOperation();
        switch (op) {
          case OP_MUTATION:
            parent = pickChild(population, fitness);
            child = mutateAST(parent);
            break;
          case OP_CROSSOVER:
            a = pickChild(population, fitness);
            b = pickChild(population, fitness);
            child = crossoverAST(a, b);
            break;
          case OP_REPRODUCTION:
            parent = pickChild(population, fitness);
            child = clone(parent);
            break;
          case OP_ALTERATION:
            parent = pickChild(population, fitness);
            child = alterAST(parent);
        }
        newPopulation[i] = child;
      }
      for (i = n = 0, ref5 = population.length; 0 <= ref5 ? n < ref5 : n > ref5; i = 0 <= ref5 ? ++n : --n) {
        population[i] = newPopulation[i];
      }
      generation++;
    }
  };

  exports.solve = solve;

  exports.generateSomewhatCorrectAST = generateSomewhatCorrectAST;

  exports.mutateAST = mutateAST;

  exports.crossoverAST = crossoverAST;

  exports.alterAST = alterAST;

}).call(this);
