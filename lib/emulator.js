// Generated by CoffeeScript 1.12.7
(function() {
  var CheckError, ComputeNode, DIR_TO_CHAR, DamagedNode, Emulator, EventEmitter, InputNode, MAX_COLUMNS, MAX_INT, MAX_LINES, MAX_STACK_SIZE, MAX_STREAM_LENGTH, MIN_INT, MemoryNode, Node, OP_ANY_READ_ORDER, OutputNode, Table, debug, fs, parserlib, speclib, statslib,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Table = require('cli-table');

  debug = require('debug');

  fs = require('fs');

  statslib = require('stats-lite');

  EventEmitter = require('events').EventEmitter;

  parserlib = require('./asm-parser');

  speclib = require('./spec');

  debug = debug('tis100');

  MAX_LINES = 15;

  MAX_COLUMNS = 18;

  MIN_INT = -999;

  MAX_INT = 999;

  MAX_STREAM_LENGTH = 39;

  MAX_STACK_SIZE = 15;

  OP_ANY_READ_ORDER = ['LEFT', 'RIGHT', 'UP', 'DOWN'];

  DIR_TO_CHAR = {
    UP: '↑',
    DOWN: '↓',
    LEFT: '←',
    RIGHT: '→'
  };

  CheckError = (function(superClass) {
    extend(CheckError, superClass);

    function CheckError(nodeIndex1, lineNumber1, raw1, message) {
      this.nodeIndex = nodeIndex1;
      this.lineNumber = lineNumber1;
      this.raw = raw1;
      this.message = message;
      CheckError.__super__.constructor.call(this, this.message);
    }

    return CheckError;

  })(Error);

  Emulator = (function(superClass) {
    extend(Emulator, superClass);

    function Emulator() {
      this.maxNodes = 12;
      this.layoutWidth = 4;
      this.ast = null;
      this.spec = null;
      this.nodes = [];
      this.inputs = [];
      this.outputs = [];
      this.cycle = 0;
      this.finished = false;
      this.passed = false;
      this.stats = {};
    }

    Emulator.prototype.calculateStats = function() {
      var actual, computeNodes, correctness, i, instrCount, k, l, len, len1, n, nodeCount, numActual, numTotal, output, ref, ref1, ref2, stddev, stddevs;
      numActual = 0;
      numTotal = 0;
      stddevs = [];
      ref = this.outputs;
      for (k = 0, len = ref.length; k < len; k++) {
        output = ref[k];
        if (!(output != null)) {
          continue;
        }
        stddevs.push((ref1 = statslib.stdev(output.actual)) != null ? ref1 : 0);
        ref2 = output.actual;
        for (i = l = 0, len1 = ref2.length; l < len1; i = ++l) {
          actual = ref2[i];
          if (actual === output.expected[i]) {
            numActual++;
          }
          numTotal++;
        }
      }
      stddev = statslib.mean(stddevs);
      correctness = numActual / numTotal;
      computeNodes = (function() {
        var len2, m, ref3, results;
        ref3 = this.nodes;
        results = [];
        for (m = 0, len2 = ref3.length; m < len2; m++) {
          n = ref3[m];
          if (n.numLogicalInstructions) {
            results.push(n);
          }
        }
        return results;
      }).call(this);
      nodeCount = computeNodes.length;
      if (computeNodes.length) {
        instrCount = ((function() {
          var len2, m, ref3, results;
          results = [];
          for (m = 0, len2 = computeNodes.length; m < len2; m++) {
            n = computeNodes[m];
            results.push((ref3 = n.numLogicalInstructions) != null ? ref3 : 0);
          }
          return results;
        })()).reduce(function(a, b) {
          return a + b;
        });
      } else {
        instrCount = 0;
      }
      this.stats.finished = this.finished;
      this.stats.passed = this.passed;
      this.stats.cycles = this.cycle;
      this.stats.actualOutputs = numActual;
      this.stats.expectedOutputs = numTotal;
      this.stats.correctness = correctness;
      this.stats.outputStddev = stddev;
      this.stats.nodeCount = nodeCount;
      this.stats.instructionCount = instrCount;
    };

    Emulator.prototype.toString = function() {
      var a, actual, arr, expected, i, j, k, l, len, len1, name, node, ref, ref1, ret, row, table;
      this.calculateStats();
      ret = '';
      table = new Table();
      row = ["TIS-100 JAVASCRIPT EMULATOR"];
      row.push(this.spec != null ? this.spec.name + '\n' + this.spec.description.join('\n') : '');
      row.push("CYCLES=" + this.stats.cycles + "\nNODES=" + this.stats.nodeCount + "\nINSTRUCTIONS=" + this.stats.instructionCount);
      row.push(this.finished ? "FINISHED\n" + (this.passed ? 'TEST PASSED OK' : 'TEST FAILED') + "\n" + (Math.round(this.stats.correctness * 100 * 1e3) / 1e3) + "% CORRECT" : 'RUNNING');
      table.push(row);
      ret += table.toString() + '\n';
      table = new Table();
      ref = [this.inputs, this.nodes, this.outputs];
      for (k = 0, len = ref.length; k < len; k++) {
        arr = ref[k];
        i = 0;
        while (i <= arr.length - 1) {
          table.push((function() {
            var l, ref1, ref2, ref3, results;
            results = [];
            for (j = l = 0, ref1 = this.layoutWidth; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
              results.push((ref2 = (ref3 = arr[i + j]) != null ? typeof ref3.toString === "function" ? ref3.toString() : void 0 : void 0) != null ? ref2 : '');
            }
            return results;
          }).call(this));
          i += 4;
        }
      }
      ret += table.toString() + '\n';
      ref1 = this.outputs;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        node = ref1[l];
        if (!(node != null)) {
          continue;
        }
        name = node.name, actual = node.actual, expected = node.expected;
        ret += name + ":\n";
        ret += " EXPECTED: " + (expected.join(' ')) + "\n";
        ret += " ACTUAL:   " + (((function() {
          var len2, m, results;
          results = [];
          for (m = 0, len2 = actual.length; m < len2; m++) {
            a = actual[m];
            if (a != null) {
              results.push(a);
            }
          }
          return results;
        })()).join(' ')) + "\n";
      }
      ret += '\n';
      return ret;
    };

    Emulator.prototype.toSaveFile = function() {
      var i, k, len, node, ref, ret;
      ret = '';
      i = 0;
      ref = this.nodes;
      for (k = 0, len = ref.length; k < len; k++) {
        node = ref[k];
        if (node instanceof ComputeNode) {
          ret += "@" + i + "\n";
          ret += node.toSaveFile();
          ret += "\n";
          i++;
        }
      }
      return ret;
    };

    Emulator.prototype.load = function(progsrc, specsrc) {
      if (specsrc != null) {
        if (/get_description/.test(specsrc)) {
          this.loadSpec(specsrc);
        } else {
          this.loadSpec(fs.readFileSync(specsrc, 'utf8'));
        }
      }
      if (progsrc != null) {
        if (/^\s*@/.test(progsrc)) {
          this.loadProgram(progsrc);
        } else {
          this.loadProgram(fs.readFileSync(progsrc, 'utf8'));
        }
      }
      this.reset();
    };

    Emulator.prototype.loadProgram = function(contents) {
      var e;
      if ((contents != null ? contents.tisasm : void 0) === 1) {
        this.ast = contents;
      } else {
        try {
          this.ast = parserlib.parse(contents);
        } catch (error) {
          e = error;
          e.contents = contents;
          throw e;
        }
      }
      this.staticCheck();
    };

    Emulator.prototype.loadSpec = function(contents) {
      var e;
      try {
        this.spec = speclib.parse(contents);
      } catch (error) {
        e = error;
        e.contents = contents;
        throw e;
      }
      this.maxNodes = this.spec.layout.length;
      this.layoutWidth = this.spec.layoutWidth;
    };

    Emulator.prototype.staticCheck = function() {
      var assertArg, comment, index, input, inputs, instruction, k, l, label, labels, layoutIndex, len, len1, len2, len3, len4, len5, len6, lineNumber, lines, m, name, node, nodeIndex, o, ok, output, outputs, p, pos, q, r, raw, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s, stream, type;
      if (((ref = this.ast) != null ? ref.tisasm : void 0) !== 1) {
        throw new Error("Expected a parsed TISasm abstract syntax tree");
      }
      ref1 = this.ast.nodes;
      for (nodeIndex = k = 0, len = ref1.length; k < len; nodeIndex = ++k) {
        ref2 = ref1[nodeIndex], index = ref2.index, lines = ref2.lines;
        if (index !== nodeIndex) {
          throw new CheckError(nodeIndex, 0, null, "Node indices must be specified in order starting from 0");
        }
        if (nodeIndex > this.maxNodes - 1) {
          throw new CheckError(nodeIndex, 0, null, "Program cannot specify more than " + this.maxNodes + " nodes");
        }
        labels = {};
        for (lineNumber = l = 0, len1 = lines.length; l < len1; lineNumber = ++l) {
          ref3 = lines[lineNumber], label = ref3.label, instruction = ref3.instruction, comment = ref3.comment, raw = ref3.raw;
          if (lineNumber > MAX_LINES - 1) {
            throw new CheckError(nodeIndex, lineNumber, raw, "Program cannot have more than " + MAX_LINES + " lines per node");
          }
          if (label != null) {
            labels[label] = lineNumber;
          }
          if ((raw != null ? raw.length : void 0) > MAX_COLUMNS + 1) {
            throw new CheckError(nodeIndex, lineNumber, raw, "Lines cannot have more than " + MAX_COLUMNS + " columns");
          }
        }
        for (lineNumber = m = 0, len2 = lines.length; m < len2; lineNumber = ++m) {
          ref4 = lines[lineNumber], label = ref4.label, instruction = ref4.instruction, comment = ref4.comment, raw = ref4.raw;
          assertArg = function(value) {
            switch (typeof value) {
              case 'string':
                if (value === 'BAK') {
                  throw new CheckError(nodeIndex, lineNumber, raw, "BAK is not addressable");
                }
                break;
              case 'number':
                if (value < MIN_INT || value > MAX_INT) {
                  throw new CheckError(nodeIndex, lineNumber, raw, "Number " + value + " exceeds range " + MIN_INT + " to " + MAX_INT);
                }
            }
          };
          if (instruction == null) {
            continue;
          }
          switch (instruction[0]) {
            case 'MOV':
              assertArg(instruction[0]);
              assertArg(instruction[1]);
              break;
            case 'ADD':
            case 'SUB':
            case 'JRO':
              assertArg(instruction[0]);
              break;
            case 'JMP':
            case 'JEZ':
            case 'JNZ':
            case 'JGZ':
            case 'JLZ':
              if (!(instruction[1] in labels)) {
                throw new CheckError(nodeIndex, lineNumber, raw, "Label '" + instruction[1] + "' is not specified in program");
              }
          }
        }
        if (this.spec != null) {
          inputs = [];
          outputs = [];
          ref5 = this.spec.streams;
          for (o = 0, len3 = ref5.length; o < len3; o++) {
            ref6 = ref5[o], type = ref6[0], name = ref6[1], pos = ref6[2], stream = ref6[3];
            switch (type) {
              case 'STREAM_INPUT':
                if (inputs[pos]) {
                  throw new Error("Duplicate input streams for position " + pos + ": " + name + " and " + inputs[pos]);
                }
                inputs[pos] = name;
                break;
              case 'STREAM_OUTPUT':
                if (outputs[pos]) {
                  throw new Error("Duplicate output streams for position " + pos + ": " + name + " and " + outputs[pos]);
                }
                outputs[pos] = name;
                break;
              default:
                throw new Error("Unknown stream type " + type + " named " + name);
            }
            if (stream.length > MAX_STREAM_LENGTH) {
              throw new Error("Stream " + name + " length is greater than max " + MAX_STREAM_LENGTH);
            }
          }
          nodeIndex = 0;
          ref7 = this.spec.layout;
          for (layoutIndex = p = 0, len4 = ref7.length; p < len4; layoutIndex = ++p) {
            type = ref7[layoutIndex];
            switch (type) {
              case 'TILE_COMPUTE':
                if (!(node = this.ast.nodes[nodeIndex])) {
                  continue;
                }
                input = inputs[layoutIndex];
                if (indexOf.call((function() {
                  results = [];
                  for (var q = 0, ref8 = this.layoutWidth; 0 <= ref8 ? q < ref8 : q > ref8; 0 <= ref8 ? q++ : q--){ results.push(q); }
                  return results;
                }).apply(this), layoutIndex) >= 0 && input) {
                  ok = false;
                  ref9 = node.lines;
                  for (r = 0, len5 = ref9.length; r < len5; r++) {
                    instruction = ref9[r].instruction;
                    if (!(node.lines != null)) {
                      continue;
                    }
                    if ((ref10 = instruction[0]) === 'MOV') {
                      ok || (ok = (ref11 = instruction[1]) === 'UP' || ref11 === 'ANY');
                    } else if ((ref12 = instruction[0]) === 'ADD' || ref12 === 'SUB' || ref12 === 'JRO') {
                      ok || (ok = (ref13 = instruction[1]) === 'UP' || ref13 === 'ANY');
                    }
                    if (ok) {
                      break;
                    }
                  }
                  if (!ok) {
                    throw new Error("Node " + layoutIndex + " must read from input " + input);
                  }
                }
                output = outputs[layoutIndex - 8];
                if (indexOf.call([8, 9, 10, 11], layoutIndex) >= 0 && output) {
                  ok = false;
                  ref14 = node.lines;
                  for (s = 0, len6 = ref14.length; s < len6; s++) {
                    instruction = ref14[s].instruction;
                    if (!(node.lines != null)) {
                      continue;
                    }
                    if ((ref15 = instruction[0]) === 'MOV') {
                      ok || (ok = (ref16 = instruction[2]) === 'DOWN' || ref16 === 'ANY');
                    }
                    if (ok) {
                      break;
                    }
                  }
                  if (!ok) {
                    throw new Error("Node " + layoutIndex + " must write to output " + output);
                  }
                }
                nodeIndex++;
                break;
              case 'TILE_MEMORY':
              case 'TILE_DAMAGED':
                break;
              default:
                throw new Error("Unknown tile type in layout " + layoutIndex + ": " + type);
            }
          }
        }
      }
    };

    Emulator.prototype.reset = function() {
      var down, i, index, k, l, left, len, len1, len2, len3, len4, m, name, node, o, p, pn, pni, pos, ref, ref1, ref2, ref3, ref4, ref5, ref6, right, stream, type, types, up;
      if (this.ast == null) {
        return;
      }
      this.cycle = 0;
      this.finished = false;
      this.passed = false;
      this.stats = {};
      this.nodes = [];
      types = ((ref = this.spec) != null ? ref.layout : void 0) || ((function() {
        var k, ref1, results;
        results = [];
        for (i = k = 0, ref1 = this.maxNodes; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          results.push('TILE_COMPUTE');
        }
        return results;
      }).call(this));
      pn = this.ast.nodes;
      pni = 0;
      for (index = k = 0, len = types.length; k < len; index = ++k) {
        type = types[index];
        node = (function() {
          var ref1, ref2;
          switch (type) {
            case 'TILE_DAMAGED':
              return new DamagedNode();
            case 'TILE_MEMORY':
              return new MemoryNode();
            case 'TILE_COMPUTE':
              return new ComputeNode((ref1 = (ref2 = pn[pni++]) != null ? ref2.lines : void 0) != null ? ref1 : []);
          }
        })();
        node.layoutIndex = index;
        node.name = (type.replace('TILE_', '')) + "-" + index;
        this.nodes.push(node);
      }
      this.inputs = new Array(4);
      this.outputs = new Array(4);
      if (((ref1 = this.spec) != null ? ref1.streams : void 0) != null) {
        ref2 = this.spec.streams;
        for (l = 0, len1 = ref2.length; l < len1; l++) {
          ref3 = ref2[l], type = ref3[0], name = ref3[1], pos = ref3[2], stream = ref3[3];
          if (type === 'STREAM_INPUT') {
            node = new InputNode(stream);
            node.layoutIndex = -4 + pos;
            node.name = name;
            this.inputs[pos] = node;
          } else {
            node = new OutputNode(stream);
            node.layoutIndex = this.maxNodes + pos;
            node.name = name;
            this.outputs[pos] = node;
          }
        }
      }
      ref4 = this.nodes;
      for (index = m = 0, len2 = ref4.length; m < len2; index = ++m) {
        node = ref4[index];
        up = index - this.layoutWidth;
        if (up < 0) {
          node.neighbor_up = this.inputs[this.layoutWidth + up];
        } else {
          node.neighbor_up = this.nodes[up];
        }
        down = index + this.layoutWidth;
        if (down > this.maxNodes - 1) {
          node.neighbor_down = this.outputs[down - this.maxNodes];
        } else {
          node.neighbor_down = this.nodes[down];
        }
        right = index + 1;
        if (right % this.layoutWidth !== 0) {
          node.neighbor_right = this.nodes[right];
        }
        left = index - 1;
        if (index % this.layoutWidth !== 0) {
          node.neighbor_left = this.nodes[left];
        }
      }
      ref5 = this.inputs;
      for (index = o = 0, len3 = ref5.length; o < len3; index = ++o) {
        node = ref5[index];
        if (node != null) {
          node.neighbor_down = this.nodes[index + this.layoutWidth];
        }
      }
      ref6 = this.outputs;
      for (index = p = 0, len4 = ref6.length; p < len4; index = ++p) {
        node = ref6[index];
        if (node != null) {
          node.neighbor_up = this.nodes[this.maxNodes - this.layoutWidth + index];
        }
      }
      this.emit('reset');
    };

    Emulator.prototype.step = function() {
      var k, l, len, len1, len2, len3, len4, len5, len6, m, node, o, output, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6;
      debug("CYCLE=" + this.cycle);
      ref = this.inputs;
      for (k = 0, len = ref.length; k < len; k++) {
        node = ref[k];
        if (node != null) {
          node.stepOne();
        }
      }
      ref1 = this.nodes;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        node = ref1[l];
        node.stepOne();
      }
      ref2 = this.outputs;
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        node = ref2[m];
        if (node != null) {
          node.stepOne();
        }
      }
      ref3 = this.inputs;
      for (o = 0, len3 = ref3.length; o < len3; o++) {
        node = ref3[o];
        if (node != null) {
          node.stepTwo();
        }
      }
      ref4 = this.nodes;
      for (p = 0, len4 = ref4.length; p < len4; p++) {
        node = ref4[p];
        node.stepTwo();
      }
      ref5 = this.outputs;
      for (q = 0, len5 = ref5.length; q < len5; q++) {
        node = ref5[q];
        if (node != null) {
          node.stepTwo();
        }
      }
      this.cycle++;
      this.finished = this.passed = true;
      ref6 = this.outputs;
      for (r = 0, len6 = ref6.length; r < len6; r++) {
        output = ref6[r];
        if (!(output != null)) {
          continue;
        }
        this.finished && (this.finished = output.finished);
        this.passed && (this.passed = output.passed);
      }
      this.emit('step');
    };

    Emulator.prototype.run = function(maxCycles) {
      if (maxCycles == null) {
        maxCycles = 1000;
      }
      while (this.cycle < maxCycles && !this.finished) {
        this.step();
      }
      this.emit('end');
    };

    return Emulator;

  })(EventEmitter);

  Node = (function() {
    function Node() {
      this.port_up = this.port_down = this.port_right = this.port_left = null;
      this.neighbor_up = this.neighbor_down = this.neighbor_right = this.neighbor_left = null;
      this.layoutIndex = null;
      this.name = "UNNAMED";
    }

    Node.prototype.toString = function() {
      return this.name + '\n';
    };

    Node.prototype.stepOne = function() {};

    Node.prototype.stepTwo = function() {};

    return Node;

  })();

  DamagedNode = (function(superClass) {
    extend(DamagedNode, superClass);

    function DamagedNode() {
      return DamagedNode.__super__.constructor.apply(this, arguments);
    }

    return DamagedNode;

  })(Node);

  MemoryNode = (function(superClass) {
    extend(MemoryNode, superClass);

    function MemoryNode() {
      MemoryNode.__super__.constructor.call(this);
      this.stack = [];
      this.ptr = null;
      this._fillValue = null;
    }

    MemoryNode.prototype.toString = function() {
      var dir, i, k, len, ref, ref1, ret;
      ret = MemoryNode.__super__.toString.apply(this, arguments).toString();
      ref = ['up', 'right', 'down', 'left'];
      for (k = 0, len = ref.length; k < len; k++) {
        dir = ref[k];
        ret += " " + DIR_TO_CHAR[dir.toUpperCase()] + "=" + ((ref1 = this["port_" + dir]) != null ? ref1 : '');
      }
      ret += '\n';
      i = MAX_STACK_SIZE;
      while (i > 0) {
        i--;
        if (this.stack.length <= i) {
          if (i > 0) {
            ret += '\n';
          }
          continue;
        }
        ret += this.iptr === i ? ' ▸ ' : '   ';
        ret += this.stack[i];
        if (i > 0) {
          ret += '\n';
        }
      }
      return ret;
    };

    MemoryNode.prototype.stepOne = function() {
      var dir, k, len, neighbor, results, value;
      results = [];
      for (k = 0, len = OP_ANY_READ_ORDER.length; k < len; k++) {
        dir = OP_ANY_READ_ORDER[k];
        if (this.stack.length >= MAX_STACK_SIZE) {
          break;
        }
        neighbor = this["neighbor_" + (dir.toLowerCase())];
        switch (dir) {
          case 'LEFT':
            value = neighbor.port_right;
            break;
          case 'RIGHT':
            value = neighbor.port_left;
            break;
          case 'UP':
            value = neighbor.port_down;
            break;
          case 'DOWN':
            value = neighbor.port_up;
        }
        if (value != null) {
          debug(this.name, 'pushing', value, 'to stack (from', dir, 'neighbor)');
          this.stack.push(value);
          results.push(neighbor.port_up = neighbor.port_right = neighbor.port_down = neighbor.port_left = null);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    MemoryNode.prototype.stepTwo = function() {
      if ((this.ptr != null) && this.port_up === null) {
        debug(this.name, 'removing value at index', this.ptr);
        this.stack.splice(this.ptr, 1);
      }
      this.ptr = this.stack.length > 0 ? this.stack.length - 1 : null;
      return this.port_up = this.port_right = this.port_down = this.port_left = this.stack[this.ptr] || null;
    };

    return MemoryNode;

  })(Node);

  ComputeNode = (function(superClass) {
    extend(ComputeNode, superClass);

    function ComputeNode(lines) {
      var instruction, iptr, k, label, len, ref;
      ComputeNode.__super__.constructor.call(this);
      this.iptr = 0;
      this.acc = 0;
      this.bak = 0;
      this.mode = 'IDLE';
      this.last = null;
      this.last_reader = null;
      this._fillValue = null;
      this.instructions = [];
      this.numLogicalInstructions = 0;
      this.labelToIptr = {};
      this.iptrToLabel = [];
      for (iptr = k = 0, len = lines.length; k < len; iptr = ++k) {
        ref = lines[iptr], label = ref.label, instruction = ref.instruction;
        this.iptrToLabel[iptr] = label;
        if (label != null) {
          this.labelToIptr[label] = iptr;
        }
        this.instructions.push(instruction);
        if (instruction != null) {
          this.numLogicalInstructions++;
        }
      }
      if (this.numLogicalInstructions > 0) {
        while (this.instructions[this.iptr] == null) {
          this.iptr++;
        }
      }
    }

    ComputeNode.prototype.toString = function() {
      var dir, i, instruction, k, l, len, len1, ref, ref1, ref2, ref3, ref4, ret;
      ret = ComputeNode.__super__.toString.apply(this, arguments).toString();
      ret += " ACC=" + this.acc + " BAK=(" + this.bak + ") LAST=" + ((ref = this.last) != null ? ref : 'N/A') + " " + this.mode + "\n";
      ref1 = ['up', 'right', 'down', 'left'];
      for (k = 0, len = ref1.length; k < len; k++) {
        dir = ref1[k];
        ret += " " + DIR_TO_CHAR[dir.toUpperCase()] + "=" + ((ref2 = this["port_" + dir]) != null ? ref2 : '');
      }
      ret += '\n';
      ref3 = this.instructions;
      for (i = l = 0, len1 = ref3.length; l < len1; i = ++l) {
        instruction = ref3[i];
        ret += this.iptr === i ? ' ▸ ' : '   ';
        if (this.iptrToLabel[i] != null) {
          ret += this.iptrToLabel[i] + ':';
        }
        ret += ' ' + ((ref4 = instruction != null ? instruction.join(' ') : void 0) != null ? ref4 : '');
        if (i < this.instructions.length - 1) {
          ret += '\n';
        }
      }
      return ret;
    };

    ComputeNode.prototype.toSaveFile = function() {
      var i, instruction, k, len, ref, ref1, ret;
      ret = '';
      ref = this.instructions;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        instruction = ref[i];
        if (this.iptrToLabel[i] != null) {
          ret += this.iptrToLabel[i] + ':';
        }
        ret += ' ' + ((ref1 = instruction != null ? instruction.join(' ') : void 0) != null ? ref1 : '');
        ret += '\n';
      }
      return ret;
    };

    ComputeNode.prototype._clamp = function(value) {
      return Math.min(MAX_INT, Math.max(MIN_INT, value));
    };

    ComputeNode.prototype._advance = function(inc, wrap) {
      var max;
      if (inc == null) {
        inc = 1;
      }
      if (wrap == null) {
        wrap = true;
      }
      max = this.instructions.length - 1;
      while (true) {
        this.iptr += inc;
        if (this.iptr > max) {
          this.iptr = wrap ? 0 : max;
          break;
        }
        if (this.iptr < 0) {
          this.iptr = 0;
        }
        if (this.instructions[this.iptr] != null) {
          break;
        }
      }
      if (this.instructions[this.iptr] == null) {
        this.iptr = 0;
      }
      if (this.numLogicalInstructions > 0) {
        while (this.instructions[this.iptr] == null) {
          this.iptr++;
        }
      }
      this.mode = 'RUN';
      debug(this.name, 'advanced to iptr', this.iptr);
    };

    ComputeNode.prototype._readFromNeighbor = function(dir) {
      var neighbor, value;
      switch (dir) {
        case 'UP':
          neighbor = this.neighbor_up;
          break;
        case 'RIGHT':
          neighbor = this.neighbor_right;
          break;
        case 'DOWN':
          neighbor = this.neighbor_down;
          break;
        case 'LEFT':
          neighbor = this.neighbor_left;
          break;
        default:
          return null;
      }
      if (neighbor == null) {
        return null;
      }
      switch (dir) {
        case 'UP':
          value = neighbor.port_down;
          break;
        case 'RIGHT':
          value = neighbor.port_left;
          break;
        case 'DOWN':
          value = neighbor.port_up;
          break;
        case 'LEFT':
          value = neighbor.port_right;
      }
      if (value == null) {
        return null;
      }
      neighbor.port_up = neighbor.port_right = neighbor.port_down = neighbor.port_left = null;
      switch (dir) {
        case 'UP':
          neighbor.last_reader = 'DOWN';
          break;
        case 'RIGHT':
          neighbor.last_reader = 'LEFT';
          break;
        case 'DOWN':
          neighbor.last_reader = 'UP';
          break;
        case 'LEFT':
          neighbor.last_reader = 'RIGHT';
      }
      return value;
    };

    ComputeNode.prototype.stepOne = function() {
      var arg1, arg2, dest, dir, k, l, len, len1, len2, m, op, ref, ref1, ref2, temp, value;
      if (this.instructions[this.iptr] == null) {
        return;
      }
      ref = this.instructions[this.iptr], op = ref[0], arg1 = ref[1], arg2 = ref[2];
      switch (op) {
        case 'NOP':
          this._advance();
          break;
        case 'SWP':
          temp = this.acc;
          this.acc = this.bak;
          this.bak = temp;
          this._advance();
          break;
        case 'SAV':
          this.bak = this.acc;
          this._advance();
          break;
        case 'NEG':
          this.acc *= -1;
          this._advance();
          break;
        case 'JRO':
          switch (arg1) {
            case 'NIL':
              this._advance(0);
              break;
            case 'ACC':
              this._advance(this.acc, false);
              break;
            case 'UP':
            case 'RIGHT':
            case 'DOWN':
            case 'LEFT':
              value = this._readFromNeighbor(arg1);
              if (value != null) {
                this._advance(value, false);
              } else {
                this.mode = 'READ';
              }
              break;
            case 'ANY':
              for (k = 0, len = OP_ANY_READ_ORDER.length; k < len; k++) {
                dir = OP_ANY_READ_ORDER[k];
                value = this._readFromNeighbor(dir);
                if (value != null) {
                  this.last = dir;
                  this._advance(value, false);
                  break;
                } else {
                  this.mode = 'READ';
                }
              }
              break;
            case 'LAST':
              if (this.last != null) {
                value = this._readFromNeighbor(this.last);
                if (value != null) {
                  this._advance(value, false);
                } else {
                  this.mode = 'READ';
                }
              } else {
                this._advance(0);
              }
              break;
            default:
              this._advance(arg1, false);
          }
          break;
        case 'JMP':
        case 'JEZ':
        case 'JNZ':
        case 'JGZ':
        case 'JLZ':
          switch (op) {
            case 'JMP':
              dest = this.labelToIptr[arg1];
              break;
            case 'JEZ':
              dest = this.acc === 0 ? this.labelToIptr[arg1] : this.iptr + 1;
              break;
            case 'JNZ':
              dest = this.acc !== 0 ? this.labelToIptr[arg1] : this.iptr + 1;
              break;
            case 'JGZ':
              dest = this.acc > 0 ? this.labelToIptr[arg1] : this.iptr + 1;
              break;
            case 'JLZ':
              dest = this.acc < 0 ? this.labelToIptr[arg1] : this.iptr + 1;
          }
          this._advance(dest - this.iptr, false);
          break;
        case 'ADD':
        case 'SUB':
          switch (arg1) {
            case 'NIL':
              this._advance();
              break;
            case 'ACC':
              value = op === 'SUB' ? -this.acc : this.acc;
              this.acc = this._clamp(this.acc + value);
              this._advance();
              break;
            case 'UP':
            case 'RIGHT':
            case 'DOWN':
            case 'LEFT':
              value = this._readFromNeighbor(arg1);
              if (value != null) {
                if (op === 'SUB') {
                  value *= -1;
                }
                this.acc = this._clamp(this.acc + value);
                this._advance();
              } else {
                this.mode = 'READ';
              }
              break;
            case 'ANY':
              for (l = 0, len1 = OP_ANY_READ_ORDER.length; l < len1; l++) {
                dir = OP_ANY_READ_ORDER[l];
                value = this._readFromNeighbor(dir);
                if (value != null) {
                  if (op === 'SUB') {
                    value *= -1;
                  }
                  this.acc = this._clamp(this.acc + value);
                  this.last = dir;
                  this._advance();
                  break;
                } else {
                  this.mode = 'READ';
                }
              }
              break;
            case 'LAST':
              if (this.last != null) {
                value = this._readFromNeighbor(this.last);
                if (value != null) {
                  if (op === 'SUB') {
                    value *= -1;
                  }
                  this.acc = this._clamp(this.acc + value);
                  this._advance();
                } else {
                  this.mode = 'READ';
                }
              } else {
                this._advance();
              }
              break;
            default:
              value = arg1;
              if (op === 'SUB') {
                value *= -1;
              }
              this.acc = this._clamp(this.acc + value);
              this._advance();
          }
          break;
        case 'MOV':
          if ((ref1 = this.mode) === 'IDLE' || ref1 === 'RUN') {
            debug(this.name, 'is in mode', this.mode);
            if (typeof arg1 === 'number') {
              value = arg1;
            } else if (arg1 === 'NIL') {
              value = 0;
            } else if (arg1 === 'ACC') {
              value = this.acc;
            } else {
              debug(this.name, 'needs to wait and read from', arg1);
              this.mode = 'READ';
            }
          }
          if ((ref2 = this.mode) === 'IDLE' || ref2 === 'RUN') {
            debug(this.name, 'is in mode', this.mode);
            if (arg2 === 'NIL' || (arg2 === 'LAST' && (typeof last === "undefined" || last === null))) {
              this._advance();
            } else if (arg2 === 'ACC') {
              this.acc = value;
              this._advance();
            } else {
              debug(this.name, 'needs to wait and write to', arg2);
              this._fillValue = value;
              this.mode = 'WRTE';
            }
            return;
          }
          if (this.mode === 'READ') {
            debug(this.name, 'must have waited to read from', arg1);
            switch (arg1) {
              case 'UP':
              case 'RIGHT':
              case 'DOWN':
              case 'LEFT':
                value = this._readFromNeighbor(arg1);
                break;
              case 'ANY':
                for (m = 0, len2 = OP_ANY_READ_ORDER.length; m < len2; m++) {
                  dir = OP_ANY_READ_ORDER[m];
                  value = this._readFromNeighbor(dir);
                  if (value != null) {
                    this.last = dir;
                    break;
                  }
                }
                break;
              case 'LAST':
                if (this.last != null) {
                  value = this._readFromNeighbor(this.last);
                } else {
                  value = 0;
                }
            }
            debug(this.name, 'read value', value);
            if (value == null) {
              return;
            }
            if (arg2 === 'NIL' || (arg2 === 'LAST' && (typeof last === "undefined" || last === null))) {
              this._advance();
            } else if (arg2 === 'ACC') {
              this.acc = value;
              this._advance();
            } else {
              debug(this.name, 'needs to wait to write', value, 'to', arg2);
              this.mode = 'WRTE';
              this._fillValue = value;
            }
          }
      }
    };

    ComputeNode.prototype.stepTwo = function() {
      var arg1, arg2, op, ref, value;
      if (this.instructions[this.iptr] == null) {
        return;
      }
      ref = this.instructions[this.iptr], op = ref[0], arg1 = ref[1], arg2 = ref[2];
      if (this._fillValue != null) {
        debug(this.name, 'has a fill value,', this._fillValue, 'and will put it in', arg2);
        this.mode = 'WRTE';
        switch (arg2) {
          case 'UP':
            this.port_up = this._fillValue;
            break;
          case 'RIGHT':
            this.port_right = this._fillValue;
            break;
          case 'DOWN':
            this.port_down = this._fillValue;
            break;
          case 'LEFT':
            this.port_left = this._fillValue;
            break;
          case 'ANY':
            this.port_up = this.port_right = this.port_down = this.port_left = this._fillValue;
            break;
          case 'LAST':
            switch (this.last) {
              case 'UP':
                this.port_up = this._fillValue;
                break;
              case 'RIGHT':
                this.port_right = this._fillValue;
                break;
              case 'DOWN':
                this.port_down = this._fillValue;
                break;
              case 'LEFT':
                this.port_left = this._fillValue;
            }
        }
        this._fillValue = null;
        return;
      }
      if (op === 'MOV' && this.mode === 'WRTE') {
        switch (arg2) {
          case 'UP':
            value = this.port_up;
            break;
          case 'RIGHT':
            value = this.port_right;
            break;
          case 'DOWN':
            value = this.port_down;
            break;
          case 'LEFT':
            value = this.port_left;
            break;
          case 'ANY':
            value = this.port_up;
            break;
          case 'LAST':
            switch (this.last) {
              case 'UP':
                value = this.port_up;
                break;
              case 'RIGHT':
                value = this.port_right;
                break;
              case 'DOWN':
                value = this.port_down;
                break;
              case 'LEFT':
                value = this.port_left;
            }
        }
        if (value != null) {
          debug(this.name, 'needs to write', value, 'to', arg2);
        }
        if (value == null) {
          debug(this.name, 'has been drained');
          if (arg2 === 'ANY') {
            this.last = this.last_reader;
          }
          this._advance();
        }
      }
    };

    return ComputeNode;

  })(Node);

  InputNode = (function(superClass) {
    extend(InputNode, superClass);

    function InputNode(stream1) {
      this.stream = stream1;
      InputNode.__super__.constructor.call(this);
      this.ptr = 0;
      this.mode = 'RUN';
      this.port_down = null;
    }

    InputNode.prototype.toString = function() {
      var ref, ret;
      ret = this.name + " " + this.mode + " ↓=" + ((ref = this.port_down) != null ? ref : '');
      return ret;
    };

    InputNode.prototype.stepTwo = function() {
      var value;
      if (this.port_down != null) {
        this.mode = 'WRTE';
      } else {
        if (this.mode === 'WRTE') {
          this.mode = 'RUN';
        } else if (this.mode === 'RUN') {
          value = this.stream[this.ptr];
          if (value != null) {
            this.port_down = this.stream[this.ptr];
            this.ptr++;
            this.mode = 'WRTE';
          } else {
            this.mode = 'IDLE';
          }
        }
      }
    };

    return InputNode;

  })(Node);

  OutputNode = (function(superClass) {
    extend(OutputNode, superClass);

    function OutputNode(expected1) {
      this.expected = expected1;
      OutputNode.__super__.constructor.call(this);
      this.actual = new Array(this.expected.length);
      this.ptr = 0;
      this.mode = 'READ';
      this.neighbor_up = null;
      this.passed = true;
      this.finished = false;
    }

    OutputNode.prototype.toString = function() {
      var ret;
      ret = this.name;
      ret += ' ' + this.mode;
      ret += ' - ' + (this.passed ? 'OK' : 'NOT OK');
      if (this.finished) {
        ret += ' - FINISHED';
      }
      return ret;
    };

    OutputNode.prototype.stepOne = function() {
      var value;
      if (this.neighbor_up == null) {
        return;
      }
      value = this.neighbor_up.port_down;
      if (value != null) {
        this.neighbor_up.port_up = this.neighbor_up.port_right = this.neighbor_up.port_down = this.neighbor_up.port_left = null;
        if (this.ptr < this.expected.length) {
          this.actual[this.ptr] = value;
        }
        this.finished = this.actual[this.actual.length - 1] != null;
        if (this.actual[this.ptr] != null) {
          this.passed && (this.passed = this.actual[this.ptr] === this.expected[this.ptr]);
        }
        this.ptr++;
      }
    };

    return OutputNode;

  })(Node);

  exports.CheckError = CheckError;

  exports.Emulator = Emulator;

  exports.MAX_LINES = MAX_LINES;

  exports.MIN_INT = MIN_INT;

  exports.MAX_INT = MAX_INT;

}).call(this);
